// App.jsx - TextShareApp component
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import './App.css';
import AppHeader from './components/AppHeader.jsx';
import HomeContainer from './components/HomeContainer.jsx';
import TextAreaContainer from './components/TextAreaContainer.jsx';
import ControlsBar from './components/ControlsBar.jsx';
import Footer from './components/Footer.jsx';
import ShareModal from './components/ShareModal.jsx';
import { useTheme } from './theme/ThemeContext.jsx';
import { enableWebRTCDebug, sendWebRTCLogs } from './utils/WebRTCDebug.js';
import { useWebRTCManager } from './utils/WebRTCSocketManager.js';

// Constants
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '/api';
const LOGO_URL = import.meta.env.VITE_LOGO_URL || '/clippy.png';
const MAX_TEXT_LENGTH = 20000; // Limit text to 20,000 characters (approx. 20KB)
const MAX_STORAGE_SIZE = 4 * 1024 * 1024; // 4MB limit for localStorage

// TextShareApp Component
function TextShareApp({ id, seedData }) {
  // Helper function to encode text to base64
  const encodeTextToBase64 = (text) => {
    try {
      return btoa(encodeURIComponent(text));
    } catch (e) {
      console.error('Error encoding text to base64:', e);
      return '';
    }
  };
  
  // Helper function to decode base64 to text
  const decodeBase64ToText = (base64) => {
    try {
      return decodeURIComponent(atob(base64));
    } catch (e) {
      console.error('Error decoding base64 to text:', e);
      return '';
    }
  };

  // Theme
  const { theme } = useTheme();
  
  // Navigation and parameters
  const navigate = useNavigate();
  
  // State for text
  const [text, setText] = useState('');
  const [savedText, setSavedText] = useState('');
  const [serverText, setServerText] = useState('');
  const [lastServerText, setLastServerText] = useState('');
  const [loadedFromServer, setLoadedFromServer] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);
  const [isTyping, setIsTyping] = useState(false);
  const [showModal, setShowModal] = useState(false);
  const [isRtcConnected, setIsRtcConnected] = useState(false);
  const [isRtcPollingPaused, setIsRtcPollingPaused] = useState(false);
  const [isServerOnline, setIsServerOnline] = useState(true);
  const [isSocketConnected, setIsSocketConnected] = useState(false);
  const [socketClients, setSocketClients] = useState(0);
  
  // Refs
  const textAreaRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  const isTypingRef = useRef(false);
  const savingTimeoutRef = useRef(null);
  const clientIdRef = useRef(null);
  const lastActivityTimeRef = useRef(Date.now());
  const userEditingRef = useRef(false);
  
  // Generate a client ID if we don't have one
  if (!clientIdRef.current) {
    clientIdRef.current = Math.random().toString(36).substring(2, 10);
    console.log(`Generated client ID: ${clientIdRef.current}`);
  }
  
  // Initialize WebRTC
  const {
    rtcSupported,
    rtcConnected,
    connectionStatus,
    activeUsers: rtcActiveUsers,
    dataChannelStatus,
    webRtcConnectionStage: rtcStage,
    isPollingPaused: rtcPollingPaused,
    sendTextToAllPeers,
    initiatePeerConnections
  } = useWebRTCManager(
    id,
    text,
    setText,
    setSavedText,
    setServerText,
    setLastServerText,
    setHasChanges,
    isTypingRef.current
  );
  
  // Update our state when WebRTCSocketManager state changes
  useEffect(() => {
    if (rtcConnected !== undefined) {
      setIsRtcConnected(rtcConnected);
    }
  }, [rtcConnected]);
  
  useEffect(() => {
    if (rtcPollingPaused !== undefined) {
      setIsRtcPollingPaused(rtcPollingPaused);
    }
  }, [rtcPollingPaused]);

  // WebRTC Socket Manager handles all WebRTC signaling now - no polling needed

  // Track user activity for auto-save and offline detection
  const updateLastActivityTime = useCallback(() => {
    lastActivityTimeRef.current = Date.now();
    
    // If user is active and WebRTC polling was paused due to inactivity, resume
    if (isRtcPollingPaused) {
      console.log('User activity detected, resuming WebRTC polling');
      setIsRtcPollingPaused(false);
    }
  }, [isRtcPollingPaused]);
  
  // Monitor user activity
  useEffect(() => {
    const handleActivity = () => {
      updateLastActivityTime();
    };
    
    // Add event listeners for user activity
    window.addEventListener('mousemove', handleActivity);
    window.addEventListener('keypress', handleActivity);
    window.addEventListener('touchstart', handleActivity);
    window.addEventListener('click', handleActivity);
    
    // Set initial activity time
    updateLastActivityTime();
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('mousemove', handleActivity);
      window.removeEventListener('keypress', handleActivity);
      window.removeEventListener('touchstart', handleActivity);
      window.removeEventListener('click', handleActivity);
    };
  }, [updateLastActivityTime]);
  
  // Handle typing status
  const handleTypingStart = useCallback(() => {
    if (!isTypingRef.current) {
      isTypingRef.current = true;
      setIsTyping(true);
    }
    
    // Clear existing timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Set a new timeout
    typingTimeoutRef.current = setTimeout(() => {
      isTypingRef.current = false;
      setIsTyping(false);
    }, 2000);
  }, []);
  
  // Handle text changes
  const handleChange = useCallback((e) => {
    const newText = e.target.value;
    
    // Only process if text has actually changed
    if (newText !== text) {
      // Handle typing indicator
      handleTypingStart();
      
      // Enforce max length
      if (newText.length > MAX_TEXT_LENGTH) {
        alert(`Text is too long. Maximum length is ${MAX_TEXT_LENGTH} characters.`);
        return;
      }
      
      // Update text state
      setText(newText);
      setHasChanges(newText !== serverText);
      userEditingRef.current = true;
      
      // Handle auto-save with debounce
      if (savingTimeoutRef.current) {
        clearTimeout(savingTimeoutRef.current);
      }
      
      savingTimeoutRef.current = setTimeout(() => {
        handleSave();
      }, 2000); // Auto-save after 2 seconds of inactivity
      
      // If connected via WebRTC, broadcast to peers
      if (rtcConnected) {
        sendTextToAllPeers(newText);
      }
    }
  }, [text, serverText, rtcConnected, sendTextToAllPeers, handleTypingStart]);
  
  // Handle save operation
  const handleSave = useCallback(async () => {
    // Skip saving if no changes
    if (!hasChanges || !id) return;
    
    // Skip saving if text is too long
    if (text.length > MAX_TEXT_LENGTH) {
      alert(`Text is too long. Maximum length is ${MAX_TEXT_LENGTH} characters.`);
      return;
    }
    
    const tempText = text;
    setSavedText(tempText);
    
    try {
      const headers = new Headers();
      headers.append('Content-Type', 'application/json');
      headers.append('X-Client-ID', clientIdRef.current);
      
      const response = await fetch(`${API_BASE_URL}/share.php?id=${id}`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ text: tempText })
      });
      
      const data = await response.json();
      
      if (data.status === 'success') {
        setServerText(tempText);
        setLastServerText(tempText);
        setHasChanges(false);
        console.log('Text saved to server');
        
        // Update online status if it was offline
        if (!isServerOnline) {
          setIsServerOnline(true);
        }
        
        // Store in localStorage as backup
        try {
          const key = `clippy_text_${id}`;
          localStorage.setItem(key, encodeTextToBase64(tempText));
          console.log('Text saved to localStorage');
        } catch (e) {
          console.error('Error saving to localStorage:', e);
        }
      } else {
        console.error('Error saving text:', data.message);
      }
    } catch (error) {
      console.error('Error saving text:', error);
      setIsServerOnline(false);
      
      // If the server is offline, still store in localStorage
      try {
        const key = `clippy_text_${id}`;
        localStorage.setItem(key, encodeTextToBase64(tempText));
        console.log('Text saved to localStorage (server offline)');
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }
    }
  }, [id, text, hasChanges, isServerOnline]);
  
  // Load text from server
  const loadTextFromServer = useCallback(async () => {
    if (!id) return;
    
    try {
      const headers = new Headers();
      headers.append('X-Client-ID', clientIdRef.current);
      
      const response = await fetch(`${API_BASE_URL}/share.php?id=${id}&track=true`, {
        headers
      });
      
      const data = await response.json();
      
      if (data.status === 'success') {
        console.log('Text loaded from server');
        
        // Update server text state
        setServerText(data.text);
        setLastServerText(data.text);
        
        // Only update the text if we haven't loaded yet or user isn't editing
        if (!loadedFromServer || !userEditingRef.current) {
          setText(data.text);
          setSavedText(data.text);
          setHasChanges(false);
        } else if (data.text !== text) {
          // If we already loaded and the server text is different, mark changes
          setHasChanges(true);
        }
        
        // Mark as loaded
        setLoadedFromServer(true);
        
        // Update online status if it was offline
        if (!isServerOnline) {
          setIsServerOnline(true);
        }
        
        // Store in localStorage as backup
        try {
          const key = `clippy_text_${id}`;
          localStorage.setItem(key, encodeTextToBase64(data.text));
        } catch (e) {
          console.error('Error saving to localStorage:', e);
        }
      } else {
        console.error('Error loading text:', data.message);
      }
    } catch (error) {
      console.error('Error loading text from server:', error);
      setIsServerOnline(false);
      
      // Try to get from localStorage as fallback
      try {
        const key = `clippy_text_${id}`;
        const savedText = localStorage.getItem(key);
        
        if (savedText) {
          const decodedText = decodeBase64ToText(savedText);
          console.log('Text loaded from localStorage (server offline)');
          setText(decodedText);
          setSavedText(decodedText);
          setLoadedFromServer(true);
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }
    }
  }, [id, text, loadedFromServer]);
  
  // Initial load effect
  useEffect(() => {
    if (id) {
      loadTextFromServer();
      
      // If there's seed data, use it
      if (seedData && !loadedFromServer) {
        setText(seedData);
        setSavedText(seedData);
        setHasChanges(true);
      }
    }
  }, [id, seedData, loadTextFromServer, loadedFromServer]);
  
  // Handle copy to clipboard
  const handleCopy = useCallback(() => {
    if (!navigator.clipboard) {
      alert('Clipboard API not available in your browser');
      return;
    }
    
    navigator.clipboard.writeText(text)
      .then(() => {
        console.log('Text copied to clipboard');
        
        // Flash the UI to indicate success
        const textAreaContainer = document.querySelector('.text-area-container');
        if (textAreaContainer) {
          textAreaContainer.classList.add('copied');
          setTimeout(() => {
            textAreaContainer.classList.remove('copied');
          }, 200);
        }
      })
      .catch(err => {
        console.error('Error copying text to clipboard:', err);
        alert('Failed to copy text to clipboard');
      });
  }, [text]);
  
  // Handle share button click
  const handleShare = useCallback(() => {
    setShowModal(true);
  }, []);
  
  // Handle modal close
  const handleCloseModal = useCallback(() => {
    setShowModal(false);
  }, []);
  
  // Create a new document
  const handleNew = useCallback(() => {
    // Generate a new ID and navigate to it
    const newId = Math.random().toString(16).substring(2, 18);
    navigate(`/${newId}`);
    
    // Reset state
    setText('');
    setSavedText('');
    setServerText('');
    setLastServerText('');
    setHasChanges(false);
    setLoadedFromServer(false);
  }, [navigate]);
  
  // Calculate stats
  const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
  const charCount = text.length;
  
  // Assemble WebRTC status message
  const getWebRTCStatusMessage = useCallback(() => {
    if (!rtcSupported) {
      return 'WebRTC not supported';
    }
    
    if (rtcConnected) {
      const otherClients = rtcActiveUsers - 1;
      const clientLabel = otherClients === 1 ? 'client' : 'clients';
      return `Connected via WebRTC\n(${otherClients} other ${clientLabel})`;
    }
    
    if (rtcStage === 'connecting') {
      return 'WebRTC connecting...';
    }
    
    if (rtcStage === 'discovering') {
      return 'Looking for peers...';
    }
    
    if (rtcStage === 'failed') {
      return 'WebRTC connection failed';
    }
    
    return 'WebRTC ready';
  }, [rtcSupported, rtcConnected, rtcStage, rtcActiveUsers]);
  
  // Enable WebRTC Debug
  const handleDebugWebRTC = useCallback(() => {
    enableWebRTCDebug();
  }, []);
  
  // Handle Debug Log Submit
  const handleSubmitDebugLogs = useCallback(async () => {
    if (!id) return;
    
    try {
      const result = await sendWebRTCLogs(id, clientIdRef.current);
      console.log('Debug log submission result:', result);
      alert(result.message);
    } catch (error) {
      console.error('Error submitting debug logs:', error);
      alert('Failed to submit debug logs');
    }
  }, [id]);
  
  // Render
  return (
    <div className={`app-container ${theme}`}>
      <AppHeader
        logo={LOGO_URL}
        onNew={handleNew}
        showRTCStatus={!!id}
        rtcStatus={getWebRTCStatusMessage()}
        rtcConnected={rtcConnected}
        rtcStage={rtcStage}
        onDebugWebRTC={handleDebugWebRTC}
        onSubmitDebugLogs={handleSubmitDebugLogs}
      />
      
      {!id ? (
        <HomeContainer onNewClick={handleNew} />
      ) : (
        <>
          <TextAreaContainer
            value={text}
            onChange={handleChange}
            textAreaRef={textAreaRef}
            rtcStatus={rtcStage}
            isTyping={isTyping}
          />
          
          <ControlsBar
            hasChanges={hasChanges}
            isServerOnline={isServerOnline}
            isRtcConnected={isRtcConnected}
            wordCount={wordCount}
            charCount={charCount}
            onSave={handleSave}
            onCopy={handleCopy}
            onShare={handleShare}
            onRefresh={loadTextFromServer}
            showRTCControls={rtcSupported}
            rtcPollingPaused={isRtcPollingPaused}
            rtcStage={rtcStage}
          />
        </>
      )}
      
      <Footer />
      
      {showModal && (
        <ShareModal
          id={id}
          onClose={handleCloseModal}
          rtcSupported={rtcSupported}
          rtcConnected={rtcConnected}
        />
      )}
    </div>
  );
}

export default TextShareApp;
